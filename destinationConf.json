{"slots":{"0":{"name":"DB","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"10":{"name":"slot11","type":{"events":[],"methods":[]}},"11":{"name":"slot12","type":{"events":[],"methods":[]}},"12":{"name":"slot13","type":{"events":[],"methods":[]}},"13":{"name":"slot14","type":{"events":[],"methods":[]}},"14":{"name":"slot15","type":{"events":[],"methods":[]}},"15":{"name":"slot16","type":{"events":[],"methods":[]}},"16":{"name":"slot17","type":{"events":[],"methods":[]}},"17":{"name":"slot18","type":{"events":[],"methods":[]}},"18":{"name":"slot19","type":{"events":[],"methods":[]}},"19":{"name":"slot20","type":{"events":[],"methods":[]}},"20":{"name":"slot21","type":{"events":[],"methods":[]}},"21":{"name":"slot22","type":{"events":[],"methods":[]}},"22":{"name":"slot23","type":{"events":[],"methods":[]}},"23":{"name":"slot24","type":{"events":[],"methods":[]}},"24":{"name":"slot25","type":{"events":[],"methods":[]}},"25":{"name":"slot26","type":{"events":[],"methods":[]}},"26":{"name":"slot27","type":{"events":[],"methods":[]}},"27":{"name":"slot28","type":{"events":[],"methods":[]}},"28":{"name":"slot29","type":{"events":[],"methods":[]}},"29":{"name":"slot30","type":{"events":[],"methods":[]}},"30":{"name":"slot31","type":{"events":[],"methods":[]}},"31":{"name":"slot32","type":{"events":[],"methods":[]}},"32":{"name":"slot33","type":{"events":[],"methods":[]}},"33":{"name":"slot34","type":{"events":[],"methods":[]}},"34":{"name":"slot35","type":{"events":[],"methods":[]}},"35":{"name":"slot36","type":{"events":[],"methods":[]}},"36":{"name":"slot37","type":{"events":[],"methods":[]}},"37":{"name":"slot38","type":{"events":[],"methods":[]}},"38":{"name":"slot39","type":{"events":[],"methods":[]}},"39":{"name":"slot40","type":{"events":[],"methods":[]}},"40":{"name":"slot41","type":{"events":[],"methods":[]}},"41":{"name":"slot42","type":{"events":[],"methods":[]}},"42":{"name":"slot43","type":{"events":[],"methods":[]}},"43":{"name":"slot44","type":{"events":[],"methods":[]}},"44":{"name":"slot45","type":{"events":[],"methods":[]}},"45":{"name":"slot46","type":{"events":[],"methods":[]}},"46":{"name":"slot47","type":{"events":[],"methods":[]}},"47":{"name":"slot48","type":{"events":[],"methods":[]}},"48":{"name":"slot49","type":{"events":[],"methods":[]}},"49":{"name":"slot50","type":{"events":[],"methods":[]}},"50":{"name":"slot51","type":{"events":[],"methods":[]}},"51":{"name":"slot52","type":{"events":[],"methods":[]}},"52":{"name":"slot53","type":{"events":[],"methods":[]}},"53":{"name":"slot54","type":{"events":[],"methods":[]}},"54":{"name":"slot55","type":{"events":[],"methods":[]}},"55":{"name":"slot56","type":{"events":[],"methods":[]}},"56":{"name":"slot57","type":{"events":[],"methods":[]}},"57":{"name":"slot58","type":{"events":[],"methods":[]}},"58":{"name":"slot59","type":{"events":[],"methods":[]}},"59":{"name":"slot60","type":{"events":[],"methods":[]}},"60":{"name":"slot61","type":{"events":[],"methods":[]}},"61":{"name":"slot62","type":{"events":[],"methods":[]}},"62":{"name":"slot63","type":{"events":[],"methods":[]}},"63":{"name":"slot64","type":{"events":[],"methods":[]}},"64":{"name":"slot65","type":{"events":[],"methods":[]}},"65":{"name":"slot66","type":{"events":[],"methods":[]}},"66":{"name":"slot67","type":{"events":[],"methods":[]}},"67":{"name":"slot68","type":{"events":[],"methods":[]}},"68":{"name":"slot69","type":{"events":[],"methods":[]}},"69":{"name":"slot70","type":{"events":[],"methods":[]}},"70":{"name":"slot71","type":{"events":[],"methods":[]}},"71":{"name":"slot72","type":{"events":[],"methods":[]}},"72":{"name":"slot73","type":{"events":[],"methods":[]}},"73":{"name":"slot74","type":{"events":[],"methods":[]}},"74":{"name":"slot75","type":{"events":[],"methods":[]}},"75":{"name":"slot76","type":{"events":[],"methods":[]}},"76":{"name":"slot77","type":{"events":[],"methods":[]}},"77":{"name":"slot78","type":{"events":[],"methods":[]}},"78":{"name":"slot79","type":{"events":[],"methods":[]}},"79":{"name":"slot80","type":{"events":[],"methods":[]}},"80":{"name":"slot81","type":{"events":[],"methods":[]}},"81":{"name":"slot82","type":{"events":[],"methods":[]}},"82":{"name":"slot83","type":{"events":[],"methods":[]}},"83":{"name":"slot84","type":{"events":[],"methods":[]}},"84":{"name":"slot85","type":{"events":[],"methods":[]}},"85":{"name":"slot86","type":{"events":[],"methods":[]}},"86":{"name":"slot87","type":{"events":[],"methods":[]}},"87":{"name":"slot88","type":{"events":[],"methods":[]}},"88":{"name":"slot89","type":{"events":[],"methods":[]}},"89":{"name":"slot90","type":{"events":[],"methods":[]}},"90":{"name":"slot91","type":{"events":[],"methods":[]}},"91":{"name":"slot92","type":{"events":[],"methods":[]}},"92":{"name":"slot93","type":{"events":[],"methods":[]}},"93":{"name":"slot94","type":{"events":[],"methods":[]}},"94":{"name":"slot95","type":{"events":[],"methods":[]}},"95":{"name":"slot96","type":{"events":[],"methods":[]}},"96":{"name":"slot97","type":{"events":[],"methods":[]}},"97":{"name":"slot98","type":{"events":[],"methods":[]}},"98":{"name":"slot99","type":{"events":[],"methods":[]}},"99":{"name":"slot100","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"--system.print(tableIO.tableToString(unit))\nlocal opLimit = 50 --export: operations per second\nlocal coRoIndex = 0\nDataWriteComplete = false\nlocal classList = {\n    ['Industry1'] = true,\n    ['Industry2'] = true,\n    ['Industry3'] = true,\n    ['Industry4'] = true,\n    ['Industry5'] = true,\n    ['IndustryUnit'] = true\n}\nlocal industryString = DB.getStringValue('Industry')\n--system.print(industryString)\nlocal industryData = tableIO.stringToTable(industryString)\n--system.print(type(industryData))\n--system.print(tableIO.tableToString(industryData))\n\nlocal slotTable = {}\nfunction WriteData()\n    for slotName in pairs(unit) do\n        coRoIndex = coRoIndex + 1\n        --system.print('slotOp: ' .. coRoIndex)\n        if coRoIndex > opLimit then\n            coRoIndex = 0\n            coroutine.yield()\n        end\n\n        if type(unit[slotName])=='table' and  slotName~= nil and unit[slotName].getClass ~= nil and slotName~='system' and slotName~='library' and slotName~='unit' and slotName~='export' then\n\n            slotTable[#slotTable + 1] = slotName\n            system.print('added ' .. unit[slotName].getName() .. ' to the table at ' .. slotName)\n        end\n    end\n    system.print(tableIO.tableToString(slotTable))\n\n    for key, slot in pairs(slotTable) do\n        coRoIndex = coRoIndex + 1\n        if coRoIndex > opLimit then\n            coRoIndex = 0\n            coroutine.yield()\n        end\n\n        if classList[unit[slot].getClass()] then\n            local id = unit[slot].getLocalId()\n            local sid = 's' .. id\n            if industryData[sid] then\n                if unit[slot].getState() == 1 then\n                    unit[slot].setOutput(industryData[sid].item)\n                    if industryData[sid].mode == 2 then --maintain\n                        unit[slot].startMaintain(industryData[sid].maintain)\n                    elseif industryData[sid].mode == 1 then --infinite\n                        unit[slot].startRun()\n                    elseif industryData[sid].mode == 0 then --off\n                    end\n                else --industry not stopped!\n                    system.print(id .. ' unit is not stopped! value is ' .. unit[slot].getState())\n                end\n            else --sid not in table!\n                system.print('connections sid not found in master table: ' .. sid)\n            end\n        else --not of industry classlist type!\n            system.print('class not in industry: ' .. unit[slot].getClass() .. '\\n id: ' .. id)\n        end\n    end\n    DataWriteComplete = true\n    system.print('COMPLETE!')\n    unit.exit()\nend\n\nWriteData = coroutine.create(WriteData)\nunit.setTimer('second',1)\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"if DataWriteComplete == false then\n    coroutine.resume(WriteData)\nend","filter":{"args":[{"value":"second"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"1"},{"code":"--tableIO\n--https://github.com/LexLoki/tableIO\n\n--  The MIT License (MIT)\n--  Copyright © 2016 Pietro Ribeiro Pepe.\n\n--  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n--  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n--  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n-- Script to write table to file\n-- Version 1.2 - 2017/04/10\n\ntableIO = {}\n\nlocal writeTable,getString,prints,strings,write\n\n------------------------------------------\n-- Public functions\n------------------------------------------\n\n--[[ tableIO.tableToString\nGets the tableIO serialization string of a given table\n-\nParams:\n\tt: the table to be serialized with tableIO\n\t(optional)name: the name the table will have on the file, default is 'table'\n-\nReturns:\n\t-string: the tableIO serialization of the table\n]]\nfunction tableIO.tableToString(t)\n\treturn getString(t)\nend\n\n--[[ tableIO.stringToTable\nConverts a tableIO serialization string to a table\n-\nParams:\n\tstring: a tableIO serialization string to be converted to table\n-\nReturns:\n\t-table: the conversion of the string\n]]\nfunction tableIO.stringToTable(string)\n\tlocal lines = {}\n\tfor i in string.gmatch(string, '[^\\n\\t,]+') do\n\t\t--print(i)\n  \t\ttable.insert(lines,i)\n\tend\n\treturn getTable(lines)\nend\n\n--[[ tableIO.saveOnFile\nSave a table to a opened file. It saves field by field\n-\nParams:\n\tfile: the opened file\n\tt: the table\n\t(optional)name: the name the table will have on the file, default is 'table'\n-\nReturns:\n\t-boolean: whether or not the save operation was successfull\n\t-string: when not successfull, the error message, otherwise, nil\n]]\nfunction tableIO.saveOnFile(file,t,name)\n\tname = name or 'table'\n\tfile:write('local '..name..' = ')\n\twriteTable(t,file)\n\tfile:write('\\n\\nreturn '..name)\nend\n\n--[[ tableIO.save\nSave a table to a path, using io. It saves field by field\n-\nParams:\n\tt: the table\n\tpath: a string represeting where the file should be saved\n\t(optional)name: the name the table will have on the file, default is 'table'\n-\nReturns:\n\t-boolean: whether or not the save operation was successfull\n\t-string: when not successfull, the error message, otherwise, nil\n]]\nfunction tableIO.save(t,path,name)\n\tif type(t)~='table' then\n\t\treturn false,'The input must be a table'\n\tend\n\tlocal file = io.open(path,'w')\n\tif file==nil then\n\t\treturn false,'The file could not be opened'\n\tend\n\ttableIO.saveOnFile(file,t,name)\n\tio.close(file)\n\treturn true\nend\n\n------------------------------------------\n-- Private functions and data\n------------------------------------------\n\nwrite = function(v,file)\n\tfile:write(v)\nend\n\nlocal prints = {\n\tnumber = write,\n\tboolean = function(bool,file) write(tostring(bool),file) end,\n\tstring = function(string,file) write(\"'\"..string ..\"'\",file) end,\n\ttable = function(t,file,offset) writeTable(t,file,offset) end\n}\n\nlocal strings = {\n\tnumber = tostring,\n\tboolean = tostring,\n\tstring = function(string) return \"'\"..string ..\"'\" end,\n\ttable = function(t,offset) return getString(t,offset) end\n}\n\nfunction writeTable(t,file,offset)\n\toffset = offset or ''\n\tfile:write('{')\n\tlocal off = offset..'\\t'\n\tlocal first = true\n\tfor i,v in pairs(t) do\n\t\tlocal f = prints[type(v)]\n\t\tif f then\n\t\t\tif first then first = false\n\t\t\telse file:write(',') end\n\t\t\tfile:write('\\n')\n\t\t\tif type(i)~='number' or i==0 then\n\t\t\t\tfile:write(off..i..' = ')\n\t\t\telse\n\t\t\t\tfile:write(off)\n\t\t\tend\n\t\t\t f(v,file,off)\n\t\tend\n\tend\n\tfile:write('\\n'..offset..'}')\nend\n\nfunction getString(t,offset)\n\toffset = offset or ''\n\tlocal off = offset..'\\t'\n\tlocal str = '{'..off\n\tlocal first = true\n\tfor i,v in pairs(t) do\n\t\tlocal f = strings[type(v)]\n\t\tif f then\n\t\t\tif first then first=false\n\t\t\telse str=str ..',' end\n\t\t\tstr = str ..'\\n'..off ..strings[type(i)](i)..' = '..f(v,off)\n\t\tend\n\tend\n\treturn str ..'\\n'..offset ..'}'\nend\n\nfunction getTable(lines,idx)\n\tif idx then idx=idx+1 else idx=2 end\n\tlocal t = {}\n\tlocal line=lines[idx]\n\tlocal strs,key,value,c\n\twhile line~='}' do\n\t\tstrs = {}\n\t\tfor i in string.gmatch(line,'[^=]+') do table.insert(strs,i) end\n\t\tstrs[1] = strs[1]:sub(1,strs[1]:len()-1)\n\t\tstrs[2] = strs[2]:sub(2)\n\t\tif string.sub(strs[1],1,1)==\"'\" then key = string.sub(strs[1],2,string.len(strs[1])-1)\n\t\telse key = tonumber(strs[1]) end\n\t\tc = string.sub(strs[2],1,1)\n\t\tif c==\"'\" then t[key] = string.sub(strs[2],2,string.len(strs[2])-1)\n\t\telseif c=='{' then t[key],idx = getTable(lines,idx)\n\t\telseif c=='t' then t[key]=true\n\t\telseif c=='f' then t[key]=false\n\t\telse t[key] = tonumber(strs[2]) end\n\t\tidx = idx+1\n\t\tline = lines[idx]\n\tend\n\treturn t,idx\nend\n\nreturn tableIO","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"2"},{"code":"----------------------------------------------------------------\n--                    SERIALIZER BY ELIAS                     --\n----------------------------------------------------------------\nlocal concat = table.concat\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = key .. \"=\"\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n    \n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return '\"' .. value .. '\"'\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n    return concat(t)\nend\n\nfunction deserialize(s)\n  if s == nil then return s end\n\n  local f = load(\"return \" .. s)\n\n  if f ~= nil then return f() end\n  system.print(tostring(s))\n  return nil\nend\n\n-----------------------------------------------\n--     Simple json decode alternative by J   -- \n-----------------------------------------------\nlocal unicode = {\n   {'\\\\u00e0' ,'à'},\n   {'\\\\u00e1' ,'á'},\n   {'\\\\u00e2' ,'â'},\n   {'\\\\u00e3' ,'ã'},\n   {'\\\\u00e4' ,'ä'},\n   {'\\\\u00e5' ,'å'},\n   {'\\\\u00e6' ,'æ'},\n   {'\\\\u00e7' ,'ç'},\n   {'\\\\u00e8' ,'è'},\n   {'\\\\u00e9' ,'é'},\n   {'\\\\u00ea' ,'ê'},\n   {'\\\\u00eb' ,'ë'},\n   {'\\\\u00ec' ,'ì'},\n   {'\\\\u00ed' ,'í'},\n   {'\\\\u00ee' ,'î'},\n   {'\\\\u00ef' ,'ï'},\n   {'\\\\u00f0' ,'ð'},\n   {'\\\\u00f1' ,'ñ'},\n   {'\\\\u00f2' ,'ò'},\n   {'\\\\u00f3' ,'ó'},\n   {'\\\\u00f4' ,'ô'},\n   {'\\\\u00f5' ,'õ'},\n   {'\\\\u00f6' ,'ö'},\n   {'\\\\u00f8' ,'ø'},\n   {'\\\\u00f9' ,'ù'},\n   {'\\\\u00fa' ,'ú'},\n   {'\\\\u00fb' ,'û'},\n   {'\\\\u00fc' ,'ü'},\n   {'\\\\u00fd' ,'ý'},\n   {'\\\\u00ff' ,'ÿ'},\n   {'\\\\u00df' ,'ß'}\n}\n\nfunction toboolean(str)\n    local bool = nil\n    if str == \"true\" then\n        bool = true\n    elseif str == \"false\" then\n        bool = false\n    end\n    return bool\nend\n\nfunction uniDecode(str)\n    for k, v in pairs(unicode) do\n        str = str:gsub(v[1], v[2])\n    end\n    return str\nend\n\nfunction decodedInput(encodedInput)\n    local nStr = string.gsub(encodedInput, \"%\\\\u(%x%x%x%x)\", function(a)return utf8.char(tonumber(a,16))end)\n    return nStr\nend\n\n--function dataDecode(String) --!!!doesnt work for API returning tables!!! (strings / numbers / booleans only; example: core.getData()/fuel_tank.getData())\n--    local r1 = {}\n--    local r2 = {}\n--    local rf = {}\n--    local s = string.sub(String,2,-3)\n--    s = s:gsub('%\\\"', \"\")\n--    for match in (s..\",\"):gmatch(\"(.-),\") do\n--        r1[#r1+1] = decodedInput(match)\n--    end\n--    for i , v in ipairs(r1) do\n--        for match in (v..\":\"):gmatch(\"(.-):\") do\n--            r2[#r2+1] = decodedInput(match)\n--        end\n--    end\n--    for i , v in ipairs(r2) do\n--        if (i % 2 ~= 0) then\n--            if tonumber(r2[i+1])~= nil then\n--                rf[v] = tonumber(r2[i+1])\n--            elseif r2[i+1] == \"true\" or r2[i+1] == \"false\" then\n--                rf[v] = toboolean(r2[i+1])\n--           else\n--                rf[v] = r2[i+1]\n--            end\n--        end\n--    end\n--    return rf\n--end\n\nfunction dataDecode(string)\n    string = decodedInput(string)\n    local replaced = string:gsub('[[]', '{'):gsub('[]]', '}'):gsub('\"(%w+)\":', '[\"%1\"]=')\n    return load('return ' .. replaced)()\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"3"}],"methods":[],"events":[]}
